{"version":3,"file":"async-validator.js","sources":["uni_modules/uview-plus/libs/util/async-validator.js"],"sourcesContent":["function _extends() {\n    _extends = Object.assign || function (target) {\n        for (let i = 1; i < arguments.length; i++) {\n            const source = arguments[i]\n\n            for (const key in source) {\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key]\n                }\n            }\n        }\n\n        return target\n    }\n\n    return _extends.apply(this, arguments)\n}\n\n/* eslint no-console:0 */\nconst formatRegExp = /%[sdj%]/g\nlet warning = function warning() {} // don't print warning message when in production env or node runtime\n\nif (typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production' && typeof window\n\t!== 'undefined' && typeof document !== 'undefined') {\n    warning = function warning(type, errors) {\n        if (typeof console !== 'undefined' && console.warn) {\n            if (errors.every((e) => typeof e === 'string')) {\n                console.warn(type, errors)\n            }\n        }\n    }\n}\n\nfunction convertFieldsError(errors) {\n    if (!errors || !errors.length) return null\n    const fields = {}\n    errors.forEach((error) => {\n        const { field } = error\n        fields[field] = fields[field] || []\n        fields[field].push(error)\n    })\n    return fields\n}\n\nfunction format() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key]\n    }\n\n    let i = 1\n    const f = args[0]\n    const len = args.length\n\n    if (typeof f === 'function') {\n        return f.apply(null, args.slice(1))\n    }\n\n    if (typeof f === 'string') {\n        let str = String(f).replace(formatRegExp, (x) => {\n            if (x === '%%') {\n                return '%'\n            }\n\n            if (i >= len) {\n                return x\n            }\n\n            switch (x) {\n            case '%s':\n                return String(args[i++])\n\n            case '%d':\n                return Number(args[i++])\n\n            case '%j':\n                try {\n                    return JSON.stringify(args[i++])\n                } catch (_) {\n                    return '[Circular]'\n                }\n\n                break\n\n            default:\n                return x\n            }\n        })\n\n        for (let arg = args[i]; i < len; arg = args[++i]) {\n            str += ` ${arg}`\n        }\n\n        return str\n    }\n\n    return f\n}\n\nfunction isNativeStringType(type) {\n    return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern'\n}\n\nfunction isEmptyValue(value, type) {\n    if (value === undefined || value === null) {\n        return true\n    }\n\n    if (type === 'array' && Array.isArray(value) && !value.length) {\n        return true\n    }\n\n    if (isNativeStringType(type) && typeof value === 'string' && !value) {\n        return true\n    }\n\n    return false\n}\n\nfunction asyncParallelArray(arr, func, callback) {\n    const results = []\n    let total = 0\n    const arrLength = arr.length\n\n    function count(errors) {\n        results.push.apply(results, errors)\n        total++\n\n        if (total === arrLength) {\n            callback(results)\n        }\n    }\n\n    arr.forEach((a) => {\n        func(a, count)\n    })\n}\n\nfunction asyncSerialArray(arr, func, callback) {\n    let index = 0\n    const arrLength = arr.length\n\n    function next(errors) {\n        if (errors && errors.length) {\n            callback(errors)\n            return\n        }\n\n        const original = index\n        index += 1\n\n        if (original < arrLength) {\n            func(arr[original], next)\n        } else {\n            callback([])\n        }\n    }\n\n    next([])\n}\n\nfunction flattenObjArr(objArr) {\n    const ret = []\n    Object.keys(objArr).forEach((k) => {\n        ret.push.apply(ret, objArr[k])\n    })\n    return ret\n}\n\nfunction asyncMap(objArr, option, func, callback) {\n    if (option.first) {\n        const _pending = new Promise((resolve, reject) => {\n            const next = function next(errors) {\n                callback(errors)\n                return errors.length ? reject({\n                    errors,\n                    fields: convertFieldsError(errors)\n                }) : resolve()\n            }\n\n            const flattenArr = flattenObjArr(objArr)\n            asyncSerialArray(flattenArr, func, next)\n        })\n\n        _pending.catch((e) => e)\n\n        return _pending\n    }\n\n    let firstFields = option.firstFields || []\n\n    if (firstFields === true) {\n        firstFields = Object.keys(objArr)\n    }\n\n    const objArrKeys = Object.keys(objArr)\n    const objArrLength = objArrKeys.length\n    let total = 0\n    const results = []\n    const pending = new Promise((resolve, reject) => {\n        const next = function next(errors) {\n            results.push.apply(results, errors)\n            total++\n\n            if (total === objArrLength) {\n                callback(results)\n                return results.length ? reject({\n                    errors: results,\n                    fields: convertFieldsError(results)\n                }) : resolve()\n            }\n        }\n\n        if (!objArrKeys.length) {\n            callback(results)\n            resolve()\n        }\n\n        objArrKeys.forEach((key) => {\n            const arr = objArr[key]\n\n            if (firstFields.indexOf(key) !== -1) {\n                asyncSerialArray(arr, func, next)\n            } else {\n                asyncParallelArray(arr, func, next)\n            }\n        })\n    })\n    pending.catch((e) => e)\n    return pending\n}\n\nfunction complementError(rule) {\n    return function (oe) {\n        if (oe && oe.message) {\n            oe.field = oe.field || rule.fullField\n            return oe\n        }\n\n        return {\n            message: typeof oe === 'function' ? oe() : oe,\n            field: oe.field || rule.fullField\n        }\n    }\n}\n\nfunction deepMerge(target, source) {\n    if (source) {\n        for (const s in source) {\n            if (source.hasOwnProperty(s)) {\n                const value = source[s]\n\n                if (typeof value === 'object' && typeof target[s] === 'object') {\n                    target[s] = { ...target[s], ...value }\n                } else {\n                    target[s] = value\n                }\n            }\n        }\n    }\n\n    return target\n}\n\n/**\n *  Rule for validating required fields.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction required(rule, value, source, errors, options, type) {\n    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {\n        errors.push(format(options.messages.required, rule.fullField))\n    }\n}\n\n/**\n *  Rule for validating whitespace.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction whitespace(rule, value, source, errors, options) {\n    if (/^\\s+$/.test(value) || value === '') {\n        errors.push(format(options.messages.whitespace, rule.fullField))\n    }\n}\n\n/* eslint max-len:0 */\n\nconst pattern = {\n    // http://emailregex.com/\n    email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n    url: new RegExp(\n        '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$',\n        'i'\n    ),\n    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i\n}\nvar types = {\n    integer: function integer(value) {\n        return /^(-)?\\d+$/.test(value);\n    },\n    float: function float(value) {\n        return /^(-)?\\d+(\\.\\d+)?$/.test(value);\n    },\n    array: function array(value) {\n        return Array.isArray(value)\n    },\n    regexp: function regexp(value) {\n        if (value instanceof RegExp) {\n            return true\n        }\n\n        try {\n            return !!new RegExp(value)\n        } catch (e) {\n            return false\n        }\n    },\n    date: function date(value) {\n        return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear\n\t\t\t=== 'function'\n    },\n    number: function number(value) {\n        if (isNaN(value)) {\n            return false\n        }\n\n        // 修改源码，将字符串数值先转为数值\n        return typeof +value === 'number'\n    },\n    object: function object(value) {\n        return typeof value === 'object' && !types.array(value)\n    },\n    method: function method(value) {\n        return typeof value === 'function'\n    },\n    email: function email(value) {\n        return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255\n    },\n    url: function url(value) {\n        return typeof value === 'string' && !!value.match(pattern.url)\n    },\n    hex: function hex(value) {\n        return typeof value === 'string' && !!value.match(pattern.hex)\n    }\n}\n/**\n *  Rule for validating the type of a value.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction type(rule, value, source, errors, options) {\n    if (rule.required && value === undefined) {\n        required(rule, value, source, errors, options)\n        return\n    }\n\n    const custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex']\n    const ruleType = rule.type\n\n    if (custom.indexOf(ruleType) > -1) {\n        if (!types[ruleType](value)) {\n            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type))\n        } // straight typeof check\n    } else if (ruleType && typeof value !== rule.type) {\n        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type))\n    }\n}\n\n/**\n *  Rule for validating minimum and maximum allowed values.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction range(rule, value, source, errors, options) {\n    const len = typeof rule.len === 'number'\n    const min = typeof rule.min === 'number'\n    const max = typeof rule.max === 'number' // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）\n\n    const spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\n    let val = value\n    let key = null\n    const num = typeof value === 'number'\n    const str = typeof value === 'string'\n    const arr = Array.isArray(value)\n\n    if (num) {\n        key = 'number'\n    } else if (str) {\n        key = 'string'\n    } else if (arr) {\n        key = 'array'\n    } // if the value is not of a supported type for range validation\n    // the validation rule rule should use the\n    // type property to also test for a particular type\n\n    if (!key) {\n        return false\n    }\n\n    if (arr) {\n        val = value.length\n    }\n\n    if (str) {\n        // 处理码点大于U+010000的文字length属性不准确的bug，如\"𠮷𠮷𠮷\".lenght !== 3\n        val = value.replace(spRegexp, '_').length\n    }\n\n    if (len) {\n        if (val !== rule.len) {\n            errors.push(format(options.messages[key].len, rule.fullField, rule.len))\n        }\n    } else if (min && !max && val < rule.min) {\n        errors.push(format(options.messages[key].min, rule.fullField, rule.min))\n    } else if (max && !min && val > rule.max) {\n        errors.push(format(options.messages[key].max, rule.fullField, rule.max))\n    } else if (min && max && (val < rule.min || val > rule.max)) {\n        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max))\n    }\n}\n\nconst ENUM = 'enum'\n/**\n *  Rule for validating a value exists in an enumerable list.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction enumerable(rule, value, source, errors, options) {\n    rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : []\n\n    if (rule[ENUM].indexOf(value) === -1) {\n        errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')))\n    }\n}\n\n/**\n *  Rule for validating a regular expression pattern.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction pattern$1(rule, value, source, errors, options) {\n    if (rule.pattern) {\n        if (rule.pattern instanceof RegExp) {\n            // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n            // flag is accidentally set to `true`, which in a validation scenario\n            // is not necessary and the result might be misleading\n            rule.pattern.lastIndex = 0\n\n            if (!rule.pattern.test(value)) {\n                errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern))\n            }\n        } else if (typeof rule.pattern === 'string') {\n            const _pattern = new RegExp(rule.pattern)\n\n            if (!_pattern.test(value)) {\n                errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern))\n            }\n        }\n    }\n}\n\nconst rules = {\n    required,\n    whitespace,\n    type,\n    range,\n    enum: enumerable,\n    pattern: pattern$1\n}\n\n/**\n *  Performs validation for string types.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction string(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value, 'string') && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options, 'string')\n\n        if (!isEmptyValue(value, 'string')) {\n            rules.type(rule, value, source, errors, options)\n            rules.range(rule, value, source, errors, options)\n            rules.pattern(rule, value, source, errors, options)\n\n            if (rule.whitespace === true) {\n                rules.whitespace(rule, value, source, errors, options)\n            }\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates a function.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction method(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates a number.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction number(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (value === '') {\n            value = undefined\n        }\n\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options)\n            rules.range(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates a boolean.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction _boolean(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates the regular expression type.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction regexp(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (!isEmptyValue(value)) {\n            rules.type(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates a number is an integer.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction integer(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options)\n            rules.range(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates a number is a floating point number.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction floatFn(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options)\n            rules.range(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates an array.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction array(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value, 'array') && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options, 'array')\n\n        if (!isEmptyValue(value, 'array')) {\n            rules.type(rule, value, source, errors, options)\n            rules.range(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates an object.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction object(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (value !== undefined) {\n            rules.type(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\nconst ENUM$1 = 'enum'\n/**\n *  Validates an enumerable list.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction enumerable$1(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (value !== undefined) {\n            rules[ENUM$1](rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Validates a regular expression pattern.\n *\n *  Performs validation when a rule only contains\n *  a pattern property but is not declared as a string type.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction pattern$2(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value, 'string') && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (!isEmptyValue(value, 'string')) {\n            rules.pattern(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\nfunction date(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n\n        if (!isEmptyValue(value)) {\n            let dateObject\n\n            if (typeof value === 'number') {\n                dateObject = new Date(value)\n            } else {\n                dateObject = value\n            }\n\n            rules.type(rule, dateObject, source, errors, options)\n\n            if (dateObject) {\n                rules.range(rule, dateObject.getTime(), source, errors, options)\n            }\n        }\n    }\n\n    callback(errors)\n}\n\nfunction required$1(rule, value, callback, source, options) {\n    const errors = []\n    const type = Array.isArray(value) ? 'array' : typeof value\n    rules.required(rule, value, source, errors, options, type)\n    callback(errors)\n}\n\nfunction type$1(rule, value, callback, source, options) {\n    const ruleType = rule.type\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value, ruleType) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options, ruleType)\n\n        if (!isEmptyValue(value, ruleType)) {\n            rules.type(rule, value, source, errors, options)\n        }\n    }\n\n    callback(errors)\n}\n\n/**\n *  Performs validation for any type.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param callback The callback function.\n *  @param source The source object being validated.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\nfunction any(rule, value, callback, source, options) {\n    const errors = []\n    const validate = rule.required || !rule.required && source.hasOwnProperty(rule.field)\n\n    if (validate) {\n        if (isEmptyValue(value) && !rule.required) {\n            return callback()\n        }\n\n        rules.required(rule, value, source, errors, options)\n    }\n\n    callback(errors)\n}\n\nconst validators = {\n    string,\n    method,\n    number,\n    boolean: _boolean,\n    regexp,\n    integer,\n    float: floatFn,\n    array,\n    object,\n    enum: enumerable$1,\n    pattern: pattern$2,\n    date,\n    url: type$1,\n    hex: type$1,\n    email: type$1,\n    required: required$1,\n    any\n}\n\nfunction newMessages() {\n    return {\n        default: 'Validation error on field %s',\n        required: '%s is required',\n        enum: '%s must be one of %s',\n        whitespace: '%s cannot be empty',\n        date: {\n            format: '%s date %s is invalid for format %s',\n            parse: '%s date could not be parsed, %s is invalid ',\n            invalid: '%s date %s is invalid'\n        },\n        types: {\n            string: '%s is not a %s',\n            method: '%s is not a %s (function)',\n            array: '%s is not an %s',\n            object: '%s is not an %s',\n            number: '%s is not a %s',\n            date: '%s is not a %s',\n            boolean: '%s is not a %s',\n            integer: '%s is not an %s',\n            float: '%s is not a %s',\n            regexp: '%s is not a valid %s',\n            email: '%s is not a valid %s',\n            url: '%s is not a valid %s',\n            hex: '%s is not a valid %s'\n        },\n        string: {\n            len: '%s must be exactly %s characters',\n            min: '%s must be at least %s characters',\n            max: '%s cannot be longer than %s characters',\n            range: '%s must be between %s and %s characters'\n        },\n        number: {\n            len: '%s must equal %s',\n            min: '%s cannot be less than %s',\n            max: '%s cannot be greater than %s',\n            range: '%s must be between %s and %s'\n        },\n        array: {\n            len: '%s must be exactly %s in length',\n            min: '%s cannot be less than %s in length',\n            max: '%s cannot be greater than %s in length',\n            range: '%s must be between %s and %s in length'\n        },\n        pattern: {\n            mismatch: '%s value %s does not match pattern %s'\n        },\n        clone: function clone() {\n            const cloned = JSON.parse(JSON.stringify(this))\n            cloned.clone = this.clone\n            return cloned\n        }\n    }\n}\nconst messages = newMessages()\n\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\n\nfunction Schema(descriptor) {\n    this.rules = null\n    this._messages = messages\n    this.define(descriptor)\n}\n\nSchema.prototype = {\n    messages: function messages(_messages) {\n        if (_messages) {\n            this._messages = deepMerge(newMessages(), _messages)\n        }\n\n        return this._messages\n    },\n    define: function define(rules) {\n        if (!rules) {\n            throw new Error('Cannot configure a schema with no rules')\n        }\n\n        if (typeof rules !== 'object' || Array.isArray(rules)) {\n            throw new Error('Rules must be an object')\n        }\n\n        this.rules = {}\n        let z\n        let item\n\n        for (z in rules) {\n            if (rules.hasOwnProperty(z)) {\n                item = rules[z]\n                this.rules[z] = Array.isArray(item) ? item : [item]\n            }\n        }\n    },\n    validate: function validate(source_, o, oc) {\n        const _this = this\n\n        if (o === void 0) {\n            o = {}\n        }\n\n        if (oc === void 0) {\n            oc = function oc() {}\n        }\n\n        let source = source_\n        let options = o\n        let callback = oc\n\n        if (typeof options === 'function') {\n            callback = options\n            options = {}\n        }\n\n        if (!this.rules || Object.keys(this.rules).length === 0) {\n            if (callback) {\n                callback()\n            }\n\n            return Promise.resolve()\n        }\n\n        function complete(results) {\n            let i\n            let errors = []\n            let fields = {}\n\n            function add(e) {\n                if (Array.isArray(e)) {\n                    let _errors\n\n                    errors = (_errors = errors).concat.apply(_errors, e)\n                } else {\n                    errors.push(e)\n                }\n            }\n\n            for (i = 0; i < results.length; i++) {\n                add(results[i])\n            }\n\n            if (!errors.length) {\n                errors = null\n                fields = null\n            } else {\n                fields = convertFieldsError(errors)\n            }\n\n            callback(errors, fields)\n        }\n\n        if (options.messages) {\n            let messages$1 = this.messages()\n\n            if (messages$1 === messages) {\n                messages$1 = newMessages()\n            }\n\n            deepMerge(messages$1, options.messages)\n            options.messages = messages$1\n        } else {\n            options.messages = this.messages()\n        }\n\n        let arr\n        let value\n        const series = {}\n        const keys = options.keys || Object.keys(this.rules)\n        keys.forEach((z) => {\n            arr = _this.rules[z]\n            value = source[z]\n            arr.forEach((r) => {\n                let rule = r\n\n                if (typeof rule.transform === 'function') {\n                    if (source === source_) {\n                        source = { ...source }\n                    }\n\n                    value = source[z] = rule.transform(value)\n                }\n\n                if (typeof rule === 'function') {\n                    rule = {\n                        validator: rule\n                    }\n                } else {\n                    rule = { ...rule }\n                }\n\n                rule.validator = _this.getValidationMethod(rule)\n                rule.field = z\n                rule.fullField = rule.fullField || z\n                rule.type = _this.getType(rule)\n\n                if (!rule.validator) {\n                    return\n                }\n\n                series[z] = series[z] || []\n                series[z].push({\n                    rule,\n                    value,\n                    source,\n                    field: z\n                })\n            })\n        })\n        const errorFields = {}\n        return asyncMap(series, options, (data, doIt) => {\n            const { rule } = data\n            let deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField\n\t\t\t\t=== 'object')\n            deep = deep && (rule.required || !rule.required && data.value)\n            rule.field = data.field\n\n            function addFullfield(key, schema) {\n                return { ...schema, fullField: `${rule.fullField}.${key}` }\n            }\n\n            function cb(e) {\n                if (e === void 0) {\n                    e = []\n                }\n\n                let errors = e\n\n                if (!Array.isArray(errors)) {\n                    errors = [errors]\n                }\n\n                if (!options.suppressWarning && errors.length) {\n                    Schema.warning('async-validator:', errors)\n                }\n\n                if (errors.length && rule.message) {\n                    errors = [].concat(rule.message)\n                }\n\n                errors = errors.map(complementError(rule))\n\n                if (options.first && errors.length) {\n                    errorFields[rule.field] = 1\n                    return doIt(errors)\n                }\n\n                if (!deep) {\n                    doIt(errors)\n                } else {\n                    // if rule is required but the target object\n                    // does not exist fail at the rule level and don't\n                    // go deeper\n                    if (rule.required && !data.value) {\n                        if (rule.message) {\n                            errors = [].concat(rule.message).map(complementError(rule))\n                        } else if (options.error) {\n                            errors = [options.error(rule, format(options.messages.required, rule.field))]\n                        } else {\n                            errors = []\n                        }\n\n                        return doIt(errors)\n                    }\n\n                    let fieldsSchema = {}\n\n                    if (rule.defaultField) {\n                        for (const k in data.value) {\n                            if (data.value.hasOwnProperty(k)) {\n                                fieldsSchema[k] = rule.defaultField\n                            }\n                        }\n                    }\n\n                    fieldsSchema = { ...fieldsSchema, ...data.rule.fields }\n\n                    for (const f in fieldsSchema) {\n                        if (fieldsSchema.hasOwnProperty(f)) {\n                            const fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]]\n                            fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f))\n                        }\n                    }\n\n                    const schema = new Schema(fieldsSchema)\n                    schema.messages(options.messages)\n\n                    if (data.rule.options) {\n                        data.rule.options.messages = options.messages\n                        data.rule.options.error = options.error\n                    }\n\n                    schema.validate(data.value, data.rule.options || options, (errs) => {\n                        const finalErrors = []\n\n                        if (errors && errors.length) {\n                            finalErrors.push.apply(finalErrors, errors)\n                        }\n\n                        if (errs && errs.length) {\n                            finalErrors.push.apply(finalErrors, errs)\n                        }\n\n                        doIt(finalErrors.length ? finalErrors : null)\n                    })\n                }\n            }\n\n            let res\n\n            if (rule.asyncValidator) {\n                res = rule.asyncValidator(rule, data.value, cb, data.source, options)\n            } else if (rule.validator) {\n                res = rule.validator(rule, data.value, cb, data.source, options)\n\n                if (res === true) {\n                    cb()\n                } else if (res === false) {\n                    cb(rule.message || `${rule.field} fails`)\n                } else if (res instanceof Array) {\n                    cb(res)\n                } else if (res instanceof Error) {\n                    cb(res.message)\n                }\n            }\n\n            if (res && res.then) {\n                res.then(() => cb(), (e) => cb(e))\n            }\n        }, (results) => {\n            complete(results)\n        })\n    },\n    getType: function getType(rule) {\n        if (rule.type === undefined && rule.pattern instanceof RegExp) {\n            rule.type = 'pattern'\n        }\n\n        if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {\n            throw new Error(format('Unknown rule type %s', rule.type))\n        }\n\n        return rule.type || 'string'\n    },\n    getValidationMethod: function getValidationMethod(rule) {\n        if (typeof rule.validator === 'function') {\n            return rule.validator\n        }\n\n        const keys = Object.keys(rule)\n        const messageIndex = keys.indexOf('message')\n\n        if (messageIndex !== -1) {\n            keys.splice(messageIndex, 1)\n        }\n\n        if (keys.length === 1 && keys[0] === 'required') {\n            return validators.required\n        }\n\n        return validators[this.getType(rule)] || false\n    }\n}\n\nSchema.register = function register(type, validator) {\n    if (typeof validator !== 'function') {\n        throw new Error('Cannot register a validator by type, validator is not a function')\n    }\n\n    validators[type] = validator\n}\n\nSchema.warning = warning\nSchema.messages = messages\n\nexport default Schema\n// # sourceMappingURL=index.js.map\n"],"names":["warning","type","uni","next","validate","method","number","regexp","integer","array","object","date","messages","rules","oc"],"mappings":"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"}